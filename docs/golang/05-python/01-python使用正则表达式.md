---
sidebar: auto
---

# python 中使用正则表达式

## 正则表达式的实例
了解在python中的使用方法前需要先知道正则表达式的通用

### 字符匹配
|正则|含义|
|-|-|
|`[Pp]ython`|匹配python或Python|
|`[aeiou]`|匹配方阔好内一个字符|
|`[a-zA-Z0-9]`|匹配一个大小写字母或数字|
|`[^aeioy]`|匹配除了aeiou其他任意一个字符|
|`[^0-9]`|匹配非数字字符|

### 特殊字符的匹配
|正则|含义|
|-|-|
|`.`|任意一个字符除了`\n`,可以使用`[.\n]`匹配|
|`\d`|一个数字字符，等价`[0-9]`|
|`\D`|一个非数字|
|`\s`|任何空白字符等价于 `[\f\n\r\t\v]`|
|`\S`|非空白等价于`[^\f\n\r\t\v]`|
|`\w`|等价于 `[a-zA-Z0-9_]`|
|`\W`|等价于 `[^a-zA-Z0-9_]`|
### 特殊字符的匹配
|正则|含义|
|-|-|
|`.`|任意一个字符除了`\n`,可以使用[.\n]匹配|
|`\d`|一个数字字符，等价[0-9]|
|`\D`|一个非数字|
|`^`|开头|
|`$`|结尾|
|`*`|0或多个|
|`<.*?>`|`*?`起到了非贪婪效果，匹配一个html标签|
|`+`|一或多个|
|`?`|0或一个|
|`re{n}`|必须重复n次|
|`re{n,}`|必须重复至少n次|
|`re{n,m}`|n~m次，贪婪的策略|
|`a|b`|匹配a或者b|
|`(re)`|分组|
|`(?: )`|表示不是一个分组|
|`(?# )`|表示里面是注释|
|`\1`|使用前面的分组|

## python 中 re 包

### python使用正则的函数
- 创建一个正则表达式的编译
~~~python
import re
# 一个匹配11位手机号的正则
c = re.compile(r"1[3578]{1}[0-9]{9}")
# findall 匹配所有并返回列表
c.findall("有个电话号是13844445678，这里通过正则匹配出来哈哈哈")
# finditer 匹配所有但返回生成器
c.finditer("有个电话号是13844445678，这里通过正则匹配出来哈哈哈")
# match 返回一个对象,如果没找到就返回None
c.match("有个电话号是13844445678，这里通过正则匹配出来哈哈哈")
# search 与match相同但是不限制开始位置
c.search("有个电话号是13844445678，这里通过正则匹配出来哈哈哈")
# split 跟字符串的split的方法一样的，根据匹配到的东西查分
c.split("...")
# sub 根据正则表达式替换字符串
c.sub("替换成的字符串", "需要被替换的字符串")
~~~

- 另外如果正则表达式仅适用一次，就没有必要编译`compile()`（这才是py风格） 
~~~python
...
# 简单描述一下跟编译的调用差不多
re.sub(r"o{2}", "666", "adfaoo", 5) # 把字符串前5个"oo"替换成 "666"
re.findall(r"o{2}", "adaoo,oo,oossdsaooff") # 返回满足匹配结果的字符串列表
~~~

::: danger
这是我个人自己常用的部分，基本解决工作中绝大问题
正则很强，甚至可以展开来编程了
就像linux不会所有的命令，也不是用的很嗨
:::